/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tjegades <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/03/20 10:15:00 by tjegades          #+#    #+#             */
/*   Updated: 2024/03/20 17:43:13 by achak            ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <readline/readline.h>
#include <readline/history.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <termios.h>
#include <dirent.h>

int	ft_strlen(char *s)
{
	int	len;

	len = 0;
	if (s)
		while (*s++)
			len++;
	return (len);
}

int	is_whitespace(char c)
{
	if ((c >= 9 && c <= 13) || c == ' ')
		return (1);
	return (0);
}

void detect_redirections(char *line_read)
{
	int i;
	char c;

	i = 0;
	c = line_read[i];
	while (c)
	{
		if (line_read[i] == '<')
		{
			// TODO:
			// if end of string, or special chars
			// or heredoc **IMPORTANT**

			printf("found input redirection.\n");
			// skip the redirection char,
			i++;

			// ensure we didnt reach end of line
			// print out the filename that we should be opening

			while (line_read[i] && line_read[i] == ' ')
				i++;

			// eventually we want to have this in its own string
			// so we can pass it into open()



			printf("opening file to read: ");
			while (line_read[i] && line_read[i] != ' ')
			{
				printf("%c", line_read[i]);
				i++;
			}
			printf("\n");
		}
		else if (c =='>')
		{

			// TODO:
			// if end of string, or special chars
			// or truncate **IMPORTANT**


			printf("found output redirection.\n");
			// skip the redirection char,
			i++;

			// ensure we didnt reach end of line
			// skip spaces
			while (line_read[i] && line_read[i] == ' ')
				i++;

			// print out the filename that we should be opening
			// eventually we want to have this in its own string
			// so we can pass it into open()


			printf("opening file to write: ");

			while (line_read[i] && line_read[i] != ' ')
			{
				printf("%c", line_read[i]);
				i++;
			}
			printf("\n");

		}
		i++;
		c = line_read[i];
	}
}

void	parse_line(char *line_read)
{
	int i;

	// detect pipes
	//		opening pipe
	//		forking
	//		execve cmds, args
	//		left of pipe
	//		right of pipe
	

	 // detect_redirections(line_read);

	int pid;

	pid = fork();

	if (pid == 0)
	{
		chdir("../");
		exit (1);
	}

}

char	*strjoin_and_frees1(char *s1, char *s2)
{
	char	*str;
	size_t	str_len;
	int		i;
	int		j;

	i = 0;
	j = -1;
	str_len = ft_strlen(s1) + ft_strlen(s2);
	str = (char *)malloc(sizeof(char) * (str_len + 1));
	if (!str)
		return (NULL);
	str[str_len] = '\0';
	if (s1 != NULL)
	{
		while (s1[i])
		{
			str[i] = s1[i];
			i++;
		}
		free(s1);
	}
	while (s2[++j])
		str[i++] = s2[j];
	return (str);
}
/*
void	cd_builtin(char *line_read)
{

	char	*cwd;
	DIR	*dirp;

	cwd = NULL;
	dirp = NULL;
	if (*line_read == '/')
	{
		if (chdir(line_read) == -1)
			perror("cd");
	}
	else
	{
		cwd = getcwd(NULL, 200);
		cwd = strjoin_and_frees1(cwd, "/");
		cwd = strjoin_and_frees1(cwd, line_read);
		if (chdir(line_read) == -1)
			perror("cd");
	}
}
*/

void	echo_builtin(char *line_read, int flag)
{
	if (!flag)
		printf("%s\n", line_read);
	else
		printf("%s", line_read);
}

void	pwd_builtin(void)
{
	char	*pwd;

	pwd = getcwd(NULL, 200);
	printf("%s", pwd);
	free(pwd);
}

void	sigint_handler(int sig)
{
	if (sig == SIGINT)
	{
//		if (ft_strlen(rl_line_buffer) < 2)
//			rl_replace_line("\n", 0);
//		else
//			rl_replace_line("", 0);
//		write(STDIN_FILENO, "\n", 1);
// 		printf("%d=", rl_on_new_line());
//
//		rl_replace_line("\n", 0);
		write(STDIN_FILENO, "\n ", 1);
//		printf("%d=", rl_on_new_line());
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	}
}

int main(void)
{
	static char	*line_read;
	int		i;
	int		flag;
	char	*cwd;
//	struct termios	old_termios;
//	struct termios	new_termios;
//
//	if (isatty(STDIN_FILENO))
//	{
//		if (tcgetattr(STDIN_FILENO, &old_termios) == -1)
//			perror("tcgetattr");
//	}
//	else
//		perror("isatty");
//	new_termios = old_termios;
//	new_termios.c_cc[VEOF] = 4;
//	if (tcsetattr(STDIN_FILENO, TCSANOW, &new_termios) == -1)
//		perror("tcsetattr");
	// cwd = malloc(400);
	struct sigaction	act;

	act.sa_handler = &sigint_handler;
	if (sigaction(SIGINT, &act, NULL) == -1)
		perror("sigaction");
	signal(SIGQUIT, SIG_IGN);
	flag = 0;
	i = 0;
	while (1)
	{
		if (!line_read && flag)
			exit(EXIT_SUCCESS);
		if (line_read)
		{
			free(line_read);
			line_read = NULL;
		}
		cwd = getcwd(NULL, 200);
		cwd = strjoin_and_frees1(cwd, "$ ");
		line_read = readline(cwd);
		//parse_line(line_read);
//		if (line_read && *line_read)
//			pwd_builtin();
			//echo_builtin(line_read, 1);
			//cd_builtin(line_read);
		if (line_read && *line_read)
			add_history(line_read);
		flag = 1;
	}
	free(cwd);
	//tcsetattr(STDIN_FILENO, TCSANOW, &old_termios);
}
